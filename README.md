# Pygame нтенсив
Это материал для интенсива по разработке игры Flappy Bird на языке Python с помощью библиотеки Pygame.

Материал разбит на части, последовательно повествующие о том, как работают игры и как реализовать конкретную игру 
на языке программирвоания Питон с использованием библиотеки Pygame.

## Часть 1. Базовые принципы работы игр
Чтобы сделать любую игру, необходимы:

1. **Возможность рисовать и обновлять изображение**, ведь игрок видит перед собой как раз изображение,
которое постоянно обновляется. При этом сам игрок может влиять на то, что происходит на экране
с помощью устройств ввода (клавиатура, мышь, джойстик).
Игра отличается от обычного фильма тем, что игрок влияет на изображение. Если на изображения
нельзя влиять, то это фильм.

2. **Игровая логика**, которая определяет что и где нужно рисовать на экране. То, что увидит игрок на экране,
будет зависеть от многих условий, например от:
   - ввода от игрока
   - ввода от других игроков (для многопользовательских игр)
   - логики поведения врагов
   - таймеров и временных отрезков и т.д.

Эти два требования являются основой любой игры и должны взаимодействовать, чтобы картинка реагировала на действия игрока:
нажали кнопку - игрок переместился, отпустили - игрок встал и не двигается.

Питон сам по себе не умеет рисовать изображения и показывать их нам
(в базе доступен только print и вывод в консоль).
Так же в базе питон не умеет получать ввод от пользователя без приостановке программы (ввод "на лету"),
который нужен для быстрого реагирования на действия пользователя (есть только input, 
который приостанавливает выполнение программы до ввода данных пользователем).

Поэтому нам нужна одина из библиотек, расширяющих возможнсть языка, например Pygame, Pyglet или Arcade.

Мы будем использовать **Pygame**, потому что она популярная и потому что у нас такой мастер-класс.

А ещё Pygame простой.

## Часть 2. Подключение и запуск Pygame

Установка Pygame через терминал:

```Bash
pip install pygame
```

Чтобы инициализировать (подготовить к работе) библиотеку Pygame, нужно просто написать команду для этого,
предварительньно подключив (import) библиотеку:
```Python
import pygame

pygame.init()  # Инициализация Pygame
```
_______
Весь механизм работы с Pygame можно свести к алгоритму:

1. Инициализация Pygame - pygame.init()
2. Отображение холста*
3. Игровой цикл
    * рисование изображения на холсте
    * обработка событий (клавиатура, мышь)
    * обновление холста
4. Деинициализация Pyagme - pygame.quit()


    * Холст - поверхность для отображения
_______

Основная концепция Pygame - **холст** (поверхность для отображения), на котором мы можем рисовать изображение.

Холст имеет ширину (**width**) и высоту (**height**)

Игровой цикл позволяет создать **динамическую смену** изображений на холсте и не закрыть его.

Так же в игровом цикле происходит реализация игровой логики и обновление изображения в соответствии с ней.

Например, игрок совершает действия (нажатия клавиши, движение мыши или нажатие её кнопки). Эти действия попадают в 
цикл обработки событий, который их обрабатывает (сам цикл обработки событий находитс внутри игрового цикла).
После обработки событий выплоняются команды на отрисовку изображений, которые связаны с этими событиями (нажал прыжок - 
картинка игрока начала движение вверх).

В конце игрового цикла, перед выходом на новую итерацию, происходит отрисовка всего кадра.

### Немного практики
Код ниже создаст окно размером 450 на 800 пикселя (для fhd мониторов) и отобразит его (для 2к мониторов можно сделать 576 на 1024 пикселя).
```Python
import pygame

pygame.init()
screen = pygame.display.set_mode((450, 800))

while True:
    # изображение игрока
    # фоновое изображение
    pygame.display.update()  # Выводит на экран всё, что было нарисовано в цикле
```

Просто так, нажатием на крестик, окно закрыть не получится, потому что программа не знает как реагировать на нажатие
крестика на окошке.

Чтобы научить программу реагировать на нажатие крестика, добавим обработчик событий:

```Python
import pygame

pygame.init()
screen = pygame.display.set_mode((450, 800))

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()

    pygame.display.update()  # Выводит на экран всё, что было нарисовано в цикле
```

Теперь окно закрывается, но программа завершается с ошибкой, потому что при выходе из программы по pygame.quit() цикл
не успевает завершиться полностью. Чтобы завершить цикл, понадобится библиотека sys (даёт доступ к системным функциям):

```Python
import pygame, sys

pygame.init()
screen = pygame.display.set_mode((450, 800))  # 576, 1024

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    pygame.display.update()  # Выводит на экран всё, что было нарисовано в цикле
```
При запуске этого кода в окне Pygame мы увидим сплошное черное изображение, которое никак не менется, как нам кажется.
На самом деле Pygame рисует это изображение постоянно, много раз в секунду (количество раз неизвестно).

Чтобы контролировать это количество раз (что важно для видеоигр), нужно определить
частоту кадров - FPS.

    FPS (Frames Per Second) - количество кадров (картинок, фреймов), рисуемых на холсте за одну секунду.

Количество кадров напрямую влияет на то, насколько быстро (и плавно) работает игра:
* если FPS равен 100 (ста) кадрам (сто обновлений холста в секунду) и игра двигает изображение игрока на 5 пикселей вправо каждый кадр, то игрок переместится на 500 пикселей вправо за секунду.
* если же FPS равен 10 и игра двигает изображение игрока на 5 пикселей вправо каждый кадр, то игрок переместится на 50 пикселей вправо за секунду.

Контролировать FPS можно с помощью специального объекта PyGame - **pygame.time.Clock()**

```Python
import pygame, sys

pygame.init()
screen = pygame.display.set_mode((450, 800))
clock = pygame.time.Clock()  # таймер для отсчитывания кадров

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    pygame.display.update()
    clock.tick(120)  # 120 - указанная нами частота обновления холста (FPS)
```
## Часть 3. Вывод изображений
Два типа поверхностей Images (изображения) и Surfaces (поверхности).
Поверхностей 2 типа:
Display surface - поверхность экрана
Reguls surface - обычная поверхность

По умолчанию отображается только экранная поверхность. Обычные поверхности
сами по себе не отображаются, пока вы их специально не поместите на экранную поверзность.
Поверхность - это, по сути, слой.

### Немного практики

Чтобы использовать готовые изображения, их нужно импортировать в код.
Каждое новое изображение будет размещаться на новой поверхности.
Эта поверхность (как и экран) хранится в отдельной переменной.

Метод blit(что_размещаем, где_размещаем) позволяет поместить одну поверхность на другую
что_размещаем - загруженное изображение
где_размещаем - кортеж с координатами

```Python
import pygame, sys

pygame.init()
screen = pygame.display.set_mode((450, 800))
clock = pygame.time.Clock()

bg_surface = pygame.image.load('sprites/background-day.png')  # импорт изображения, которое нужно отобразить на экране

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    screen.blit(bg_surface, (0, 0))  # размещаем на экране изображение в координате x: 0, y: 0

    pygame.display.update()
    clock.tick(120)
```
Точка отсчета координат холста (screen) находится в верхнем левом углу.
Так же и у изображения: мы работаем с верхним левым углом.
___
#### Эксперимент
Попробуйте поменять значения координат в методе **screen.blit** \
в строке с кодом **screen.blit(bg_surface, (0, 0))** на следующие:
1. 300, 0
2. 0, 200
3. 100, 200

Что произошло с фоновым изображением? Почему?
___

Сейчас фоновое изображение меньше чем экран, но его можно увеличить с помощью методов преобразования изображений.

Воспользуемся методом **transform.scale(surface, (new_width, new_height))**, который принимает на вход исходное
изображение для преобразования (**surface**) и размер, до которого его нужно преобразовать - **(new_width, new_height)**.

Так же добавим метод **convert()** загружаемому \
изображению - **pygame.image.load('sprites/background-day.png').convert()**. Он позволит преобразовать изображение в формат, с которым 
работает Pygame. Такое преобразование не обязательно, но оно позволяет ускорить
загрузку и работу игры, особенно в случае, когда на экран необходимо вывести много изображений.

```Python
import pygame, sys

pygame.init()
screen = pygame.display.set_mode((450, 800))
clock = pygame.time.Clock()

bg_surface = pygame.image.load('sprites/background-day.png').convert()  # добавляем преобразование изображения
bg_surface = pygame.transform.scale(bg_surface, (450, 800))  # Делаем фоновое изображение по размеру экрана

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    screen.blit(bg_surface, (0, 0))

    pygame.display.update()
    clock.tick(120)
```
